# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

union Userable = Admin | Contractor | Employee

type Admin {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    updated_at: DateTime!
    user: User!
}

type ClockingMachine {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    updated_at: DateTime!
}

"A paginated list of ClockingMachine items."
type ClockingMachinePaginator {
    "A list of ClockingMachine items."
    data: [ClockingMachine!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Contractor {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    status: String!
    updated_at: DateTime!
    user: User!
}

type Employee {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    status: String!
    updated_at: DateTime!
    user: User!
}

"A paginated list of Employee items."
type EmployeePaginator {
    "A list of Employee items."
    data: [Employee!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Location {
    code: String!
    created_at: DateTime!
    id: ID!
    updated_at: DateTime!
    warehouse: Warehouse!
    warehouse_area: WarehouseArea!
}

"A paginated list of Location items."
type LocationPaginator {
    "A list of Location items."
    data: [Location!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Mutation {
    createClockingMachine(name: String!): ClockingMachine!
    createLocation(code: String!): Location!
    createUser(handle: String!, name: String!, password: String!): User!
    createWarehouse(name: String!): Warehouse!
    createWarehouseArea(name: String!): WarehouseArea!
    deleteClockingMachine(id: ID!): ClockingMachine
    deleteLocation(id: ID!): Location
    deleteUser(id: ID!): User
    deleteWarehouse(id: ID!): Warehouse
    deleteWarehouseArea(id: ID!): WarehouseArea
    updateClockingMachine(id: ID!, name: String): ClockingMachine
    updateLocation(code: String, id: ID!): Location
    updateMyPassword(password: String!): User!
    updateMyPin(pin: String!): User!
    updatePassword(id: ID!, password: String!): User!
    updatePin(id: ID!, pin: String!): User!
    updateTenant(id: ID!, name: String): Tenant
    updateUser(handle: String, id: ID!, status: Boolean): User
    updateWarehouse(id: ID!, name: String): Warehouse
    updateWarehouseArea(id: ID!, name: String): WarehouseArea
}

"Pagination information about the corresponding list of items."
type PageInfo {
    "Count of nodes in current request."
    count: Int
    "Current page of request."
    currentPage: Int
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "Last page in connection."
    lastPage: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
    "Total number of node in connection."
    total: Int
}

"Pagination information about the corresponding list of items."
type PaginatorInfo {
    "Total count of available items in the page."
    count: Int!
    "Current pagination page."
    currentPage: Int!
    "Index of first item in the current page."
    firstItem: Int
    "If collection has more pages."
    hasMorePages: Boolean!
    "Index of last item in the current page."
    lastItem: Int
    "Last page number of the collection."
    lastPage: Int!
    "Number of items per page in the collection."
    perPage: Int!
    "Total items available in the collection."
    total: Int!
}

type Permission {
    created_at: DateTime!
    id: ID!
    name: String!
    roles: [Role!]!
    updated_at: DateTime!
    users: [User]!
}

"A paginated list of Permission items."
type PermissionPaginator {
    "A list of Permission items."
    data: [Permission!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Query {
    clocking_machine(slug: String): ClockingMachine
    clocking_machines(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): ClockingMachinePaginator
    employee(slug: String): Employee
    employees(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): EmployeePaginator
    location(code: String): Location
    locations(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): LocationPaginator
    me: User
    permissions(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): PermissionPaginator
    roles(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): RolePaginator
    tenant(id: ID): Tenant
    tenants(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): TenantPaginator
    user(handle: String): User
    user_auth_logs(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int,
        where: UserAuthLogsWhereWhereConditions
    ): UserAuthLogPaginator
    users(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): UserPaginator
    warehouse(slug: String): Warehouse
    warehouse_area(slug: String): WarehouseArea
    warehouse_areas(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): WarehouseAreaPaginator
    warehouses(
        "Limits number of fetched elements."
        first: Int = 100,
        "The offset from which elements are returned."
        page: Int
    ): WarehousePaginator
}

type Role {
    created_at: DateTime!
    id: ID!
    name: String!
    permissions: [Permission!]!
    updated_at: DateTime!
    users: [User]!
}

"A paginated list of Role items."
type RolePaginator {
    "A list of Role items."
    data: [Role!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Tenant {
    created_at: DateTime!
    id: ID!
    name: String!
    updated_at: DateTime!
}

"A paginated list of Tenant items."
type TenantPaginator {
    "A list of Tenant items."
    data: [Tenant!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type User {
    created_at: DateTime!
    handle: String!
    id: ID!
    status: Boolean!
    updated_at: DateTime!
    userable: Userable!
}

type UserAuthLog {
    action: String!
    handle: String!
    ip: String!
    time: String!
    user: [User]
}

"A paginated list of UserAuthLog items."
type UserAuthLogPaginator {
    "A list of UserAuthLog items."
    data: [UserAuthLog!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

"A paginated list of User items."
type UserPaginator {
    "A list of User items."
    data: [User!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

type Warehouse {
    created_at: DateTime!
    id: ID!
    name: String!
    slug: String!
    updated_at: DateTime!
    warehouse_areas: [WarehouseArea!]!
}

type WarehouseArea {
    created_at: DateTime!
    id: ID!
    locations: [Location!]!
    name: String!
    slug: String!
    updated_at: DateTime!
    warehouse: Warehouse!
}

"A paginated list of WarehouseArea items."
type WarehouseAreaPaginator {
    "A list of WarehouseArea items."
    data: [WarehouseArea!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

"A paginated list of Warehouse items."
type WarehousePaginator {
    "A list of Warehouse items."
    data: [Warehouse!]!
    "Pagination information about the list of items."
    paginatorInfo: PaginatorInfo!
}

"The available SQL operators that are used to filter query results."
enum SQLOperator {
    "Whether a value is within a range of values (`BETWEEN`)"
    BETWEEN
    "Equal operator (`=`)"
    EQ
    "Greater than operator (`>`)"
    GT
    "Greater than or equal operator (`>=`)"
    GTE
    "Whether a value is within a set of values (`IN`)"
    IN
    "Whether a value is not null (`IS NOT NULL`)"
    IS_NOT_NULL
    "Whether a value is null (`IS NULL`)"
    IS_NULL
    "Simple pattern matching (`LIKE`)"
    LIKE
    "Less than operator (`<`)"
    LT
    "Less than or equal operator (`<=`)"
    LTE
    "Not equal operator (`!=`)"
    NEQ
    "Whether a value is not within a range of values (`NOT BETWEEN`)"
    NOT_BETWEEN
    "Whether a value is not within a set of values (`NOT IN`)"
    NOT_IN
    "Negation of simple pattern matching (`NOT LIKE`)"
    NOT_LIKE
}

"The available directions for ordering a list of records."
enum SortOrder {
    "Sort records in ascending order."
    ASC
    "Sort records in descending order."
    DESC
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
    "Only return trashed results."
    ONLY
    "Return both trashed and non-trashed results."
    WITH
    "Only return non-trashed results."
    WITHOUT
}

"Allowed column names for the `where` argument on the query `user_auth_logs`."
enum UserAuthLogsWhereColumn {
    USER_ID
}

"Allows ordering a list of records."
input OrderByClause {
    "The column that is used for ordering."
    field: String!
    "The direction that is used for ordering."
    order: SortOrder!
}

"Dynamic WHERE conditions for the `where` argument on the query `user_auth_logs`."
input UserAuthLogsWhereWhereConditions {
    "A set of conditions that requires all conditions to match."
    AND: [UserAuthLogsWhereWhereConditions!]
    "A set of conditions that requires at least one condition to match."
    OR: [UserAuthLogsWhereWhereConditions!]
    "The column that is used for the condition."
    column: UserAuthLogsWhereColumn
    "The operator that is used for the condition."
    operator: SQLOperator = EQ
    "The value that is used for the condition."
    value: Mixed
}

"Dynamic WHERE conditions for queries."
input WhereConditions {
    "A set of conditions that requires all conditions to match."
    AND: [WhereConditions!]
    "A set of conditions that requires at least one condition to match."
    OR: [WhereConditions!]
    "The column that is used for the condition."
    column: String
    "The operator that is used for the condition."
    operator: SQLOperator = EQ
    "The value that is used for the condition."
    value: Mixed
}


"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date

"A datetime and timezone string in ISO 8601 format `Y-m-dTH:i:sO`, e.g. `2020-04-20T13:53:12+02:00`."
scalar DateTimeTz